\begin{savequote}[0.55\linewidth]
	\begin{fancyquote}
		The trouble with computers is you \emph{play} with them. They are so
		wonderful. You have these switches --- if it's an even number you do
		this, if it's an odd number you do that --- and pretty soon you can
		do more and more elaborate things if you are clever enough, on one
		machine.
	\end{fancyquote}
	\qauthor{ Richard Feynman in \emph{Surely You're Joking, Mr. Feynman!: Adventures of a Curious Character}, 1985 }
\end{savequote}
\chapter{Design}\label{ch:design}
% 3. Design
%    [ Describes the architectural design, patterns, design
%      decisions. Describe the libraries that are used and
%      why. Documentation system. ]

% TODO FIXME
% explain the importance of the Design phase
Once the planning is done, the actual technical details of the
project are determined in the Design phase. This phase is not a
discrete step that is separate from the following Implementation
phase; as the implementation continues, the Design is updated to
take into account new information. As such, it is important that
the Design is able to incorporate incremental changes otherwise
adding new changes will become difficult --- especially
when fundamental data structures need to be modified. The following
details these design decisions.

\section{Incorporation of \glsentrytext{orionmat}}

% start with MATLAB code and why
Since the algorithm already exists as a design in the \gls{orionmat}
implementation, this can be leveraged as a starting point for the
conversion. This means that the structure of \gls{orionc} will
start off with the same structure as the MATLAB version. This is
to reduce the cognitive load when rewriting and testing each
component because the inputs and outputs remain the same and
keeping the names the same makes it easier to navigate between
corresponding functions.

% describe naming convention and the way of linking back to
% original implementation
To facilitate this way of working, the filenames and directory
structure of the original MATLAB code are copied verbatim: instead
of using the \computertext{.m} extension for MATLAB files, the
\computertext{.c} extension is used. Inside each of these
\computertext{.c} files, a function signature is defined that
matches the one found in MATLAB with the exception that the name
is prefixed with \computertext{orion\_} such that a \gls{orionmat}
function named \computertext{hdaf} would appear as
\gls{orionc} function named \computertext{orion\_hdaf}.
This prefixing is common in C libraries as a way to provide
an application-specific namespace for symbols. This helps avoid
naming collisions where multiple libraries may define the same
symbol and these multiple definitions will need to be disambiguated.

\section{Algorithms and architecture}

The architecture of a software system includes both the individual
components and how they interact with one another and the core
data structures that are used to transfer data between the
components. The following description of the architecture will
approach these details from the top-down.

The ORION algorithm consists of three parts (as shown in
\cref{fig:high-level-arch} where data is drawn as dashed-line
ovals and processing is drawn as solid-lined rectangles),
namely
\begin{description}[font=\textpluscolon]
	\item[Segmentation] to label the
		foreground and the background of the image;
	\item[Registration] for aligning subvolumes so
		that they can be used to create a single volume;
		and
	\item[Tracing] to extract a centerline from the volume to
		capture the underlying neuron morphology.
\end{description}

\begin{figure}
\centering
\resizebox{1.0\textwidth}{!}{\input{gfx/algorithm/high-level.tex}}
\caption[High level diagram of ORION algorithm]{\textbf{High level
diagram of ORION algorithm}: This high-level diagram shows that
there are three steps to the \gls{orionmat} algorithm as described
in the text. The input to the algorithm is a 3D volume of
microscopy data and the output is a graph-based representation of
the neuron morphology based on the centerline.}\label{fig:high-level-arch}
\end{figure}

% TODO explain the current ORION algorithm
\subsection{Segmentation}

As depicted in \cref{fig:proc-segmentation}, the
segmentation process performs one-class classification using the
background voxels to learn a discriminant function for extracting
vessel-like structures. The segmentation uses a multiscale approach so that
both thin and thick neurite structures can be extracted at once from a single
volume.

\begin{figure}
\centering
\resizebox{1.0\textwidth}{!}{\input{gfx/algorithm/segmentation.tex}}
%\captionsetup{singlelinecheck=off}
\caption[Diagram of segmentation process]{\textbf{Diagram of segmentation process}:
\begin{enumerate*}[label={\alph*)}]
	\enumdescitem{Obtain background training data} This step is used
		to bootstrap the learning process so that a quick
		approximation of the distribution of background
		and foreground voxels can be determined
		(\cref{alg:seg_bg_train}).
	\enumdescitem{Obtain vessellness features} This step is used to
		obtain features that are used to discriminate
		vessel-like structures
		(\cref{alg:seg_vessellness}).
	\enumdescitem{Learn discriminant function} Here an accumulator is used to
		characterize the distribution of the vessellness features
		(\cref{alg:seg_discrim}).
	\enumdescitem{Threshold} Using the discriminant function from the previous
		step, the volume is segmented into foreground and background classes
		(\cref{alg:seg_threshold}).
	\enumdescitem{Post-processing} Removal of artifacts such as small connected components
		(\cref{alg:seg_post}).
\end{enumerate*}
}\label{fig:proc-segmentation}
\end{figure}

\begin{algorithm}
	\caption{Input parameters to segmentation}\label{alg:seg_input}
	\begin{algorithmic}[1]
		\State $I \gets \text{the input volume}$
		\State $k \gets \text{the number of scales}$
		\State $r \gets  \{ r_0, r_1, \ldots, r_{k-2}, r_{k-1} \}$
	\end{algorithmic}
\end{algorithm}

\begin{description}
	\item[\(\InputVolumeName{}\)] is the input volume of dimensions
		\(\InputVolumeDimensions{}\) which contains the intensity values taken
		from the microscope modality.
	\item[\(\RadiiScalesName{}\)] is a \Dim{\RadiiScalesName}-tuple where each element
		\(\RadiiScalesElem \in \RadiiScalesName\)
		represents the radius of the neurite to segment.
	\item[\(\LaplacianFilterApproxDegree{}\)] is the degree of the
		exponential Taylor series used to calculate the approximation
		to the Laplacian filter.
\end{description}

\begin{algorithm}
	\caption{Obtain background training data}\label{alg:seg_bg_train}
	\begin{algorithmic}[1]
		\State $n \gets \text{the degree used for approximation of low-pass filter}$
		\State $\sigma_{L}[i] \gets \left\{ \frac{0.66}{r[i]} \right\}$
			\Comment{Experimentally derived relationship between Laplacian scales and radii}
		\State $\freqdom{L}[i] \gets \Call{LaplacianFilter}{n, \sigma_{L}[i]}$
			\Comment{Construct Laplacian filters in the frequency domain}
		\State ${I}_{L}[i] \gets \IFourierTrans{ \freqdom{I} \HadamardProd \freqdom{L}[i] }$
		\State
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\caption{Obtain vessellness features}\label{alg:seg_vessellness}
	\begin{algorithmic}[1]
		$\Call{Hessian}$
		$\Call{Eigenvalues}$
		\Comment{Frangi}
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\caption{Learn discriminant function}\label{alg:seg_discrim}
	\begin{algorithmic}[1]
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\caption{Threshold}\label{alg:seg_threshold}
	\begin{algorithmic}[1]
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\caption{Post-processing}\label{alg:seg_post}
	\begin{algorithmic}[1]
	\end{algorithmic}
\end{algorithm}

\subsection{Registration}

% TODO FIXME
This step is not a set part of the neuron tracing algorithm. This
is meant to handle the subvolume.

\subsection{Tracing}

% TODO
\begin{figure}
\centering
\resizebox{1.0\textwidth}{!}{\input{gfx/algorithm/tracing.tex}}
\caption[Diagram of tracing process]{\textbf{Diagram of tracing process}}\label{fig:proc-tracing}
\end{figure}



\section{Anticipating change}

% TODO automatic prerequisite scanning

\subsection{Directory structure}

\begin{description}[font=\computertextfamily\textpluscolon]
\item[lib]
\item[lib/t]
\item[src]
\end{description}


\subsection{Build system}

% GNU make

\subsubsection{Dependencies}

% - automatic prerequisite scanning

\subsubsection{Configuration}

% - automatic compiler extension configurator (for example, GCC branch prediction __builtin_expect() macro)
% - automatic dependency build flag configuration

\subsubsection{Dev Ops}

%   provides code coverage, debug builds, profiling builds,
%   AddressSanitizer
