\begin{savequote}[0.55\linewidth]
	\begin{fancyquote}
		The trouble with computers is you \emph{play} with them. They are so
		wonderful. You have these switches --- if it's an even number you do
		this, if it's an odd number you do that --- and pretty soon you can
		do more and more elaborate things if you are clever enough, on one
		machine.
	\end{fancyquote}
	\qauthor{ Richard Feynman in \emph{Surely You're Joking, Mr. Feynman!: Adventures of a Curious Character}, 1985 }
\end{savequote}
\chapter{Design}\label{ch:design}
% 3. Design
%    [ Describes the architectural design, patterns, design
%      decisions. Describe the libraries that are used and
%      why. Documentation system. ]

% FIXME
% explain the importance of the Design phase
Once the planning is done, the actual technical details of the
project are determined in the Design phase. This phase is not a
discrete step that is separate from the following Implementation
phase; as the implementation continues, the Design is updated to
take into account new information. As such, it is important that
the Design be able to incorporate incremental changes otherwise
incorporating new changes will become difficult --- especially
when fundamental data structures need to change. The following
details these design decisions.

\section{MATLAB version of ORION 3}

% FIXME
% start with MATLAB code and why
Since the algorithm already exists as a design in the MATLAB
implementation, this can be leveraged as a starting point for the
conversion. This means that the structure of the native version of
ORION will start off with the same structure as the MATLAB
version. This is to reduce the cognitive load when rewriting and
testing each component because the inputs and outputs remain the
same.

% how the original MATLAB code is used as a starting point
In order to accomplish this, we need an overview of the MATLAB
code. One way to do this is to build a call graph, that is, a
graphical representation of which functions are called by other
functions. Using this, it is possible to trace the execution of
the code. The call graph for the MATLAB code is given in
Appendix~\ref{appx:matlab-call-graph}. By taking this call graph
and creating equivalent functions in the native code, a direct
comparison can be made between the two codebases. Thus, each
function can be converted one-by-one.

\section{Algorithms and architecture}

The architecture of a software system include both the individual
components and how they interact with one another, but the core
data structures that are used to transfer data between the
components. The following description of the architecture will
approach these details from the top-down.

The ORION algorithm consists of three parts (as shown in
Figure~\ref{fig:high-level-arch}), namely
\begin{description}
	\item[Segmentation] to label the
		foreground and the background of the image;
	\item[Registration] for aligning subvolumes so
		that they can be used to create a single volume;
		and
	\item[Tracing] to extract a centreline from the volume to
		capture the underlying neuron morphology.
\end{description}

% TODO add information about the convention used to nodes shapes
\begin{figure}
\centering
\resizebox{1.0\textwidth}{!}{\input{gfx/algorithm/high-level.tex}}
\caption[High level diagram of ORION algorithm]{\textbf{High level
diagram of ORION algorithm}: This high-level diagram shows that
there are three steps to the \gls{orionmat} algorithm as described
in the text. The input to the algorithm is a 3D volume of
microscopy data and the output is a graph-based representation of
the neuron morphology based on the centreline.}\label{fig:high-level-arch}
\end{figure}

% TODO explain the current ORION algorithm
\subsection{Segmentation}

As depicted in Figure~\ref{fig:proc-segmentation}, the
segmentation process performs one-class classification using the
background voxels to learn a discriminant function for extracting
vessel-like structures.

\begin{figure}
\centering
\resizebox{1.0\textwidth}{!}{\input{gfx/algorithm/segmentation.tex}}
\captionsetup{singlelinecheck=off}
\caption[Diagram of segmentation process]{\textbf{Diagram of segmentation process}:
\begin{description*}
	\item[Obtain background training data] This step is used
		to bootstrap the learning process so that a quick
		approximation of the distribution of background
		and foreground voxels can be determined
		(see Algorithm~\ref{alg:seg_bg_train}).
	\item[Obtain vessellness features] This step is used to
		obtain features that are used to discriminate
		vessel-like structures
		(see Algorithm~\ref{alg:seg_vessellness}).
	\item[Learn discriminant function]
		(see Algorithm~\ref{alg:seg_discrim}).
	\item[Threshold]
		(see Algorithm~\ref{alg:seg_threshold}).
	\item[Post-processing]
		(see Algorithm~\ref{alg:seg_post}).
\end{description*}
}\label{fig:proc-segmentation}
\end{figure}


\begin{algorithm}
	\caption{Obtain background training data}\label{alg:seg_bg_train}
	\begin{algorithmic}[1]
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\caption{Obtain vessellness features}\label{alg:seg_vessellness}
	\begin{algorithmic}[1]
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\caption{Learn discriminant function}\label{alg:seg_discrim}
	\begin{algorithmic}[1]
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\caption{Threshold}\label{alg:seg_threshold}
	\begin{algorithmic}[1]
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\caption{Post-processing}\label{alg:seg_post}
	\begin{algorithmic}[1]
	\end{algorithmic}
\end{algorithm}

\subsection{Registration}

% FIXME
This step is not a set part of the neuron tracing algorithm. This is mean to handle the subvolume.

\subsection{Tracing}

% TODO
\begin{figure}
\centering
\resizebox{1.0\textwidth}{!}{\input{gfx/algorithm/tracing.tex}}
\caption[Diagram of tracing process]{\textbf{Diagram of tracing process}}\label{fig:proc-tracing}
\end{figure}



\section{Anticipating change}

% TODO automatic prerequisite scanning

\subsection{Directory structure}

\begin{description}[font=\tt]
\item[lib]
\item[lib/t]
\item[src]
\end{description}


\subsection{Build system}

% GNU make

\subsubsection{Dependencies}

% - automatic prerequisite scanning

\subsubsection{Configuration}

% - automatic compiler extension configurator (for example, GCC branch prediction __builtin_expect() macro)
% - automatic dependency build flag configuration

\subsubsection{Dev Ops}

%   provides code coverage, debug builds, profiling builds,
%   AddressSanitizer
