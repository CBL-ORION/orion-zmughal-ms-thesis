\begin{savequote}[0.55\linewidth]
	\begin{fancyquote}
		Measure twice and cut once.
	\end{fancyquote}
	\qauthor{Carpentry rule of thumb}

	\begin{fancyquote}
		But cut\hspace{1em}ting is more fun than m\hspace{0.5em}\raisebox{-0.1em}{eas}\hspace{0.5em}\raisebox{-0.3em}{uri}\hspace{0.5em}\raisebox{-0.5em}{ng!}
	\end{fancyquote}
	\qauthor{Anonymous}
\end{savequote}

\chapter{Planning and Analysis}\label{ch:analysis}
% TODO
% 2. Planning and Analysis
%    [ Analysis of project requirements. How is the older codebase
%      structured. How is refactoring accomplished. ]

Before writing a single line of code, it is a good practice to understand the
scope of the problem. Gathering the deliverables and requirements of the
project is necessary not only for understanding how long the project will take,
but also the order in which to implement each component. Establishing this
order proves very useful for later in the testing phase of the project
(Chapter~\ref{ch:testing}).

\section{System objectives}\label{sec:objectives}

As opposed to the scientific deliverables discussed in
Section~\ref{sec:motivation}, the system objectives are the engineering
deliverables; these are more closely tied to the Design and Implementation
phases as these objectives influence decisions made about the underlying
resources and system architecture.

% TODO Define the project objectives (engineering deliverables).
% These are expanded from the list given in the abstract.
The \emph{first objective} is a complete conversion of the
existing code from MATLAB to native code. This involves an analysis of the
existing code to see which parts of the algorithm will be converted.

The \emph{second objective} is the ability to easily integrate the system with
Vaa3D as a plugin. This requires looking at the interface that
Vaa3D uses and creating compatible data structures so that the
data does not need to converted between multiple formats in
memory.

The \emph{third objective} is a test suite to verify that the
components of the system operated on the input and produce 
expected outputs which are comparable to the original MATLAB code
and follow expected properties outline in the design.

The \emph{fourth objective} is to ensure that the system provides
a means for reproducibility by testing the software under different
conditions and making it possible to the replicate the software
environment.

\section{Benefits}
% Analyse project requirements: why are these objectives
% beneficial?

THe first objective requires that all of the MATLAB code be
replaced by native code. This provides several benefits.
\begin{enumerate}[a)]
	\item removes a dependency on MATLAB which requires that
		all users either install a licensed copy of MATLAB
		or use the MATLAB Compiler Runtime for deployment;
	\item provides the benefit that changes in
		function behaviour between versions of
		MATLAB do not effect the output of the
		code.
	\item certain operations can run fastr in native code than
		in MATLAB.
\end{enumerate}

The second objective will allow the code to work with awidely used
tool for visualasation and analysis. Furthermore, integrating with
one tool will provide a framework for integrating with other tools
such as ImageJ. % TODO citation

The third objective provides a saftey noet so that current and
future development clearly defines the expectatiion of the code
not only in the documentation, but as executable tests that can be
used to indacate when a change causes these expectations to no
longger be met.

The fourth objective is what ensues that the prviously discussed
beneftis are available for others to use on their machines and
allowing for repduciblity of the neuron reconstruction results.
This objective is what meks the project an ``open-science''
project.


\section{Design principles}
% Define technical principles that relate to project objectives

% FIXME
In order to meet the objectives listed in
Section~\ref{sec:objectives}, certain principles need to be agreed
upon before the design phase can begin. These principles are meant
to direct how resources are used in the design and implementation.

% FIXME
Use a version control software and allow the software to be hosted
publicly: Git and GitHub.

% FIXME
Choose main implementation language so that code is portable and
easily able to be linked with other tools: write in C rather than
completely in C++.

% FIXME
Created an automated build system: use a make file build that can
bed used to build all of the system and automatically run tests:
use portable make (GNU make). Fewer instructions to read.

% FIXME
do not optimise the code until it works: use a profiler to find
where things are slow

% FIXME
use tests and debugger to incrementally build the code with
thoughtful refactoring: feedback, start from a structure of MATLAB
code and migrate to new code layout.

% FIXME
only add dependencies at the last possible moment: e.g., when you
need an FFT library, create a stub of input and output and find a
way to put library code in there.

\section{Challenges and risks}

While the code for the algorithm already exists, starting with a line-by-line
translation of the MATLAB code has some limitations outlined as follows.
\begin{description}
\item[Toolbox\label{desc:matlab:toolbox}] The code is written to use MATLAB's extensive 
	specialised toolboxes for image processing and
	statistics which means that equivalents must be
	incorporated into the new codebase.
\item[Memory management\label{desc:matlab:mem}] Since MATLAB is a dynamic array language with
	automatic memory management, it is simple to create
	multidimensional array and extend it without having to
	keep track of the variable's size or the variable
	lifetime. Since C uses manual memory management, it is
	necessary to manually allocate and release memory to avoid
	memory leaks.
\item[Data layout differences] % FIXME
	MATLAB uses column-major and 1-based indexing, while C/C++
	both used row-major and 0-based indexing. Some of the code
	will be written with the assumption that all indices start
	at 1 and this may not be documented everywhere.
\item[Caching\label{desc:matlab:cache}] The ORION MATLAB code makes frequent use of the file system
	to cache calculations between runs. The purpose of this is
	to speed up experiments so that when an experiment is
	rerun, any images that have been processed in an earlier
	stage (i.e., segmentation) do not need to be reprocessed
	in later stages (i.e., centreline extraction). Code
	written in this form imposes an algorithm structure
	that is no longer strictly imperative --- the code is now
	interspersed with checks to see if the data already exists
	and instead of passing the data between functions using
	multidimensional arrays as parameters, the parameters to
	the functions are filenames.
\item[Subvolume\label{desc:matlab:subvol}] The MATLAB code breaks up the input data into
	subvolumes. This allows the computation to run a small
	region of the data which allows for processing data that
	may be too large to fit entirely memory. Furthermore, when
	used in conjunction with the aforementioned caching, the
	steps used for each processing stage can be more granular
	which means that if any processing is incomplete (e.g.,
	because the computer runs out of memory or disk space),
	the data is not entirely lost. However, this complicates
	the algorithm because any calculation involving
	coordinates in a volume must map indices in subvolumes to
	indices in the corresponding supervolume.
\end{description}

The \nameref{desc:matlab:cache} and \nameref{desc:matlab:subvol} issues both
indicate issues that can be described as cross-cutting concerns. Cross-cutting
concerns are  % TODO aspects ...
